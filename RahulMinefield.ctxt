#BlueJ class context
comment0.params=
comment0.target=void\ init()
comment1.params=
comment1.target=void\ setupField()
comment1.text=\r\n\ \ public\ void\ setupField()\r\n\ \ \ \ Sets\ up\ the\ field\ for\ play\:\r\n\ \ \ \ -\ resets\ the\ game\ status\ to\ 0\r\n\ \ \ \ -\ populates\ the\ state\ character\ array\ to\ initial\ state\r\n\ \ \ \ -\ places\ the\ user\ in\ the\ bottom\ right\ by\ setting\ the\ state\ of\r\n\ \ \ \ \ \ the\ [9][9]\ tile\ to\ current\ uncovered\ and\ settng\ the\ user's\r\n\ \ \ \ \ \ current\ a\ and\ b\ position\r\n\ \ \ \ -\ randomly\ place\ the\ good\ and\ evil\ by\ generating\ the\ a\ and\ b\r\n\ \ \ \ \ \ positions\ for\ each.\ Ensure\ they\ are\ not\ the\ same.\r\n\ \ \ \ -\ play\ appropriate\ sound\r\n\ \ \ \ -\ call\ repaint\r\n
comment2.params=g
comment2.target=void\ paint(java.awt.Graphics)
comment2.text=\r\n\ \ public\ void\ paint(Graphics\ g)\r\n\ \ \ \ Paints\ the\ field\ using\ states\ that\ are\ stored\ in\ the\ array\r\n\ \ \ \ -\ Using\ nested\ for\ loops\ and\ a\ switch\ statement,\ check\ each\ value\ \r\n\ \ \ \ \ \ of\ the\ character\ array\ and\ depending\ on\ its\ state\r\n\ \ \ \ \ \ (field,fieldCurrent,\ uncovered,\ uncoveredCurrent)\ draw\ the\r\n\ \ \ \ \ \ right\ image\r\n\ \ \ \ -\ After\ field\ tiles\ are\ drawn,\ check\ the\ game\ status\ to\ determine\r\n\ \ \ \ \ \ if\ game\ has\ been\ lost\ or\ won,\ and\ if\ so,\ draw\ the\ good\ or\ evil\ \r\n\ \ \ \ \ \ tile\ at\ the\ user's\ current\ location\r\n\ \ \ \ -\ Request\ focus\r\n
comment3.params=e
comment3.target=void\ keyPressed(java.awt.event.KeyEvent)
comment3.text=\r\n\ \ public\ void\ keyPressed(KeyEvent\ event)\r\n\ \ \ \ Called\ in\ response\ to\ user\ key\ press.\ Takes\ appropriate\ action.\r\n\ \ \ \ -\ Retrieve\ the\ key\ code\ of\ the\ key\ that\ was\ pressed\r\n\ \ \ \ -\ If\ right,\ left,\ up\ or\ down\ was\ pressed\:\r\n\ \ \ \ \ \ -\ First\ check\ that\ it\ is\ possible\ to\ move\ (user\ is\ not\ at\r\n\ \ \ \ \ \ \ \ end\ of\ grid)\ by\ comparing\ user's\ current\ position\ to\ end\r\n\ \ \ \ \ \ \ \ position\ of\ the\ grid.\ For\ example,\ if\ the\ user\ wants\ to\r\n\ \ \ \ \ \ \ \ go\ right\ and\ the\ current\ position\ of\ user\ is\ at\ the\ 10th\r\n\ \ \ \ \ \ \ \ tile\ on\ the\ right,\ this\ move\ is\ not\ possible.\ Do\ nothing.\r\n\ \ \ \ \ \ -\ If\ it\ is\ possible\ to\ move\ in\ the\ user\ indicated\ direction,\r\n\ \ \ \ \ \ \ \ check\ if\ the\ current\ tile\ is\ covered\ or\ uncovered.\ If\r\n\ \ \ \ \ \ \ \ covered,\ set\ the\ state\ of\ next\ tile\ (tile\ to\ be\ moved\ to)\r\n\ \ \ \ \ \ \ \ to\ coveredCurrent\ state.\ If\ tile\ is\ uncovered,\ set\ next\r\n\ \ \ \ \ \ \ \ tile\ to\ uncoveredCurrent\ state.\ This\ gives\ the\ appearance\r\n\ \ \ \ \ \ \ \ of\ moving\ while\ retaining\ the\ current\ tile\ state.\r\n\ \ \ \ \ \ \ \ -\ Reset\ the\ current\ tile\ to\ not\ be\ current\ anymore\ by\ checking\r\n\ \ \ \ \ \ \ \ \ \ the\ state\ of\ the\ tile.\ \ If\ coveredCurrent,\ make\ covered\ (notCurrent).\ \r\n\ \ \ \ \ \ \ \ \ \ If\ uncoveredCurrent,\ make\ uncovered.\r\n\ \ \ \ \ \ \ \ -\ Update\ the\ user's\ current\ position\ by\ adding\ or\r\n\ \ \ \ \ \ \ \ \ \ subtracting\ one\ to\ represent\ the\ direction\ moved.\r\n\ \ \ \ -\ If\ dig\ was\ pressed\:\r\n\ \ \ \ \ \ -\ Check\ if\ tile\ is\ not\ already\ uncovered,\ which\ means\ it\r\n\ \ \ \ \ \ \ \ has\ already\ been\ dug,\ and\ no\ need\ to\ dig\ again.\r\n\ \ \ \ \ \ -\ If\ it\ is\ still\ uncovered,\ call\ checkTile()\r\n\ \ \ \ -\ Call\ repaint\ that\ will\ show\ the\ results\ of\ the\ state\ change\r\n
comment4.params=
comment4.target=void\ checkTile()
comment4.text=\r\n\ \ public\ void\ checkTile()\r\n\ \ \ \ Called\ in\ response\ to\ user\ digging.\ Determines\ evil\ or\ good\r\n\ \ \ \ is\ found,\ thus\ if\ user\ wins,\ loses\ or\ continues.\r\n\ \ \ \ -\ Check\ to\ see\ if\ user\ wins,\ loses\ or\ just\ uncoveres\ a\ tile\r\n\ \ \ \ -\ If\ win\ (user's\ position\ is\ same\ as\ good\ position),\ set\r\n\ \ \ \ \ \ game\ status\ to\ win\ and\ play\ appropriate\ sound\r\n\ \ \ \ -\ If\ lose\ (user's\ position\ is\ same\ as\ evil),\ set\ game\ status\r\n\ \ \ \ \ \ to\ lose\ and\ play\ appropriate\ sound\r\n\ \ \ \ -\ If\ neither,\ set\ tile\ state\ to\ uncovered\ current\ to\r\n\ \ \ \ \ \ indicate\ it\ has\ been\ dug\ and\ play\ appropriate\ sound.\r\n\ \ \ \ -\ Call\ repaint\ to\ show\ the\ results\ of\ the\ state\ change\r\n
comment5.params=
comment5.target=void\ uncoverField()
comment5.text=\r\n\ \ public\ void\ uncoverField()\r\n\ \ \ \ Called\ in\ response\ to\ user\ pressing\ the\ "Give\ Up"\ button.\r\n\ \ \ \ -\ Using\ nested\ for\ loops,\ reset\ the\ state\ of\ each\ tile\r\n\ \ \ \ \ \ to\ be\ uncovered.\r\n\ \ \ \ -\ Set\ game\ status\ to\ GiveUp\ (3).\r\n\ \ \ \ -\ Call\ repaint\ to\ show\ the\ results\ of\ the\ state\ change\r\n
comment6.params=e
comment6.target=void\ actionPerformed(java.awt.event.ActionEvent)
comment6.text=\r\n\ \ public\ void\ actionPerformed(ActionEvent\ e)\r\n\ \ \ \ Called\ in\ response\ to\ a\ user\ pushing\ a\ button\r\n\ \ \ \ -\ Retrieve\ the\ text\ on\ the\ button\ (matching\ it\ exactly\r\n\ \ \ \ \ \ as\ it\ is\ case-senstive)\r\n\ \ \ \ -\ If\ "Reset",\ call\ the\ setupField()\ method.\r\n\ \ \ \ -\ If\ "Give\ Up",\ call\ the\ uncoverField()\ method.\r\n
comment7.params=event
comment7.target=void\ keyReleased(java.awt.event.KeyEvent)
comment7.text=\r\n\ \ public\ void\ keyReleased(KeyEvent\ event)\r\n\ \ \ \ Called\ in\ response\ to\ a\ user\ releasing\ a\ key\r\n\ \ \ \ -\ No\ action\ required,\ but\ method\ must\ be\ defined\ in\ class\r\n\ \ \ \ \ \ for\ code\ to\ compile.\r\n
comment8.params=event
comment8.target=void\ keyTyped(java.awt.event.KeyEvent)
comment8.text=\r\n\ \ public\ void\ keyTyped(KeyEvent\ event)\r\n\ \ \ \ Called\ in\ response\ to\ a\ user\ typing\ a\ key\r\n\ \ \ \ -\ No\ action\ required,\ but\ method\ must\ be\ defined\ in\ class\r\n\ \ \ \ \ \ for\ code\ to\ compile.\r\n
numComments=9
